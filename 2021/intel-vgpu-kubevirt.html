<!doctype html>
<html lang="en">

  <head>
    <!-- Adding Adobe Analytics -->
    <script id="dpal" src="//www.redhat.com/ma/dpal.js" type="text/javascript"></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width initial-scale=1, shrink-to-fit=no" >
    <meta name="go-import" content="kubevirt.io/kubevirt git https://github.com/kubevirt/kubevirt">
    <meta name="go-import" content="kubevirt.io/client-go git https://github.com/kubevirt/client-go">
    <meta name="go-import" content="kubevirt.io/containerized-data-importer git https://github.com/kubevirt/containerized-data-importer">
    <meta name="go-import" content="kubevirt.io/hostpath-provisioner git https://github.com/kubevirt/hostpath-provisioner">
    <meta name="go-import" content="kubevirt.io/hostpath-provisioner-operator git https://github.com/kubevirt/hostpath-provisioner-operator">
    <meta name="go-import" content="kubevirt.io/qe-tools git https://github.com/kubevirt/qe-tools">
    <meta name="go-import" content="kubevirt.io/machine-remediation git https://github.com/kubevirt/machine-remediation">
    <meta name="go-import" content="kubevirt.io/cloud-provider-kubevirt git https://github.com/kubevirt/cloud-provider-kubevirt">
    <meta name="go-import" content="kubevirt.io/controller-lifecycle-operator-sdk git https://github.com/kubevirt/controller-lifecycle-operator-sdk">
    <meta name="go-import" content="kubevirt.io/ssp-operator git https://github.com/kubevirt/ssp-operator">
    <meta name="go-import" content="kubevirt.io/cpu-nfd-plugin git https://github.com/kubevirt/cpu-nfd-plugin">
    <meta name="go-import" content="kubevirt.io/containerized-data-importer-api git https://github.com/kubevirt/containerized-data-importer-api">
    <meta name="go-import" content="kubevirt.io/api git https://github.com/kubevirt/api">
    <meta name="go-import" content="kubevirt.io/node-maintenance-operator git https://github.com/kubevirt/node-maintenance-operator">
    <link rel="apple-touch-icon" sizes="72x72" href="/assets/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/favicon/site.webmanifest">
    <link rel="mask-icon" href="/assets/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#00aba9">
    <meta name="theme-color" content="#ffffff">
    <meta name="google-site-verification" content="eaETLLM6xObn1li9l9eU8lNIBgBpU0OQLXV1faU1svE" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">
    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="https://kubevirt.io//2021/intel-vgpu-kubevirt.html">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700" rel="stylesheet">
    
    <title>Using Intel vGPUs with Kubevirt | KubeVirt.io</title>
    <!-- # Opengraph protocol properties: https://ogp.me/ -->
    <meta name="author" content="Mark DeNeve" >
    <meta property="og:type" content="article" >
    <meta name="twitter:card" content="summary">
    <meta name="description" content="This blog post guides users on how to improve VM graphics performance using Intel Core processors, GPU Virtualization and Kubevirt.">
    <meta name="keywords" content="kubevirt, vGPU, Windows, GPU, Intel, minikube, Fedora" >
    <meta property="og:title" content="Using Intel vGPUs with Kubevirt | KubeVirt.io">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kubevirt.io//2021/intel-vgpu-kubevirt.html" >
    <meta property="og:image" content="https://kubevirt.io//assets/images/KubeVirt_logo_color.png">
    <meta property="og:description" content="This blog post guides users on how to improve VM graphics performance using Intel Core processors, GPU Virtualization and Kubevirt." >
    <meta property="og:site_name" content="KubeVirt.io" >
    <meta property="og:article:author" content="Mark DeNeve" >
    <meta property="og:article:published_time" content="2021-04-30 00:00:00 +0000" >
    <meta name="twitter:title" content="Using Intel vGPUs with Kubevirt | KubeVirt.io">
    <meta name="twitter:description" content="This blog post guides users on how to improve VM graphics performance using Intel Core processors, GPU Virtualization and Kubevirt.">

    <link type="application/atom+xml" rel="alternate" href="https://kubevirt.io//feed.xml" title="KubeVirt.io" />
    <script src="//code.jquery.com/jquery.min.js"></script>
    
    <!-- Photoswipe.com gallery-->

    <!-- Core CSS file -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.css">

    <!-- Skin CSS file (styling of UI - buttons, caption, etc.)
        In the folder of skin CSS file there are also:
        - .png and .svg icons sprite,
        - preloader.gif (for browsers that do not support CSS animations) -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/default-skin/default-skin.min.css">
</head>


  <body>
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top" role="navigation">
        <a class="navbar-brand" href="/">
    <img src="/assets/images/KubeVirt_logo_color.svg" class="navbar-brand-image d-inline-block align-top" alt="KubeVirt.io">
  </a>
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
    <i class="fas fa-th-large"></i>
  </button>
  <div class="collapse navbar-collapse" id="navbarSupportedContent">
    <ul class="navbar-nav">
      

      
        <li  class="nav-item active" >
          <a class="nav-link text-uppercase" href="/blogs/">Blogs</a>
        </li>
      
        <li  class="nav-item" >
          <a class="nav-link text-uppercase" href="/videos/">Videos</a>
        </li>
      
        <li  class="nav-item" >
          <a class="nav-link text-uppercase" href="/gallery/">Gallery</a>
        </li>
      
        <li  class="nav-item" >
          <a class="nav-link text-uppercase" href="//kubevirt.io/user-guide">Docs</a>
        </li>
      
        <li  class="nav-item" >
          <a class="nav-link text-uppercase" href="/labs/">Labs</a>
        </li>
      
        <li  class="nav-item" >
          <a class="nav-link text-uppercase" href="/community/">Community</a>
        </li>
      

      <li class='nav-item'>
        <form action="/search.html" class="nav-item__search" method="get" autocomplete="off">
          <div class="autocomplete" style="width:150px;">
            <input type="text" id="search-input" class="docs-search--input" placeholder="search term" name="query">
          </div>
          <input id="search-button" type="submit" value="🔍" disabled='true'>
        </form>
      </li>

    </ul>
  </div>
<script>
function autocomplete(inp, arr) {
  /*the autocomplete function takes two arguments,
  the text field element and an array of possible autocompleted values:*/
  var currentFocus;
  /*execute a function when someone writes in the text field:*/
  inp.addEventListener("input", function(e) {
      var a, b, i, val = this.value;
      /*close any already open lists of autocompleted values*/
      closeAllLists();
      if (!val) { return false;}
      currentFocus = -1;
      /*create a DIV element that will contain the items (values):*/
      a = document.createElement("DIV");
      a.setAttribute("id", this.id + "autocomplete-list");
      a.setAttribute("class", "autocomplete-items");
      /*append the DIV element as a child of the autocomplete container:*/
      this.parentNode.appendChild(a);
      /*for each item in the array...*/
      for (i = 0; i < arr.length; i++) {
        /*check if the item starts with the same letters as the text field value:*/
        if (arr[i].substr(0, val.length).toUpperCase() == val.toUpperCase()) {
          /*create a DIV element for each matching element:*/
          b = document.createElement("DIV");
          /*make the matching letters bold:*/
          b.innerHTML = "<strong>" + arr[i].substr(0, val.length) + "</strong>";
          b.innerHTML += arr[i].substr(val.length);
          /*insert a input field that will hold the current array item's value:*/
          b.innerHTML += "<input type='hidden' value='" + arr[i] + "'>";
          /*execute a function when someone clicks on the item value (DIV element):*/
              b.addEventListener("click", function(e) {
              /*insert the value for the autocomplete text field:*/
              inp.value = this.getElementsByTagName("input")[0].value;
              /*close the list of autocompleted values,
              (or any other open lists of autocompleted values:*/
              closeAllLists();
          });
          a.appendChild(b);
        }
      }
  });
  /*execute a function presses a key on the keyboard:*/
  inp.addEventListener("keydown", function(e) {
      document.getElementById("search-button").disabled= undefined;
      var x = document.getElementById(this.id + "autocomplete-list");
      if (x) x = x.getElementsByTagName("div");
      if (e.keyCode == 40) {
        /*If the arrow DOWN key is pressed,
        increase the currentFocus variable:*/
        currentFocus++;
        /*and and make the current item more visible:*/
        addActive(x);
      } else if (e.keyCode == 38) { //up
        /*If the arrow UP key is pressed,
        decrease the currentFocus variable:*/
        currentFocus--;
        /*and and make the current item more visible:*/
        addActive(x);
      } else if (e.keyCode == 13) {
        /*If the ENTER key is pressed, prevent the form from being submitted,*/
        if (currentFocus > -1) {
          /*and simulate a click on the "active" item:*/
          if (x) {
            x[currentFocus].click();
            e.preventDefault();
          }
        }
        if (document.getElementById("search-input").value == "") {
          e.preventDefault();
        }
      }
  });
  function addActive(x) {
    /*a function to classify an item as "active":*/
    if (!x) return false;
    /*start by removing the "active" class on all items:*/
    removeActive(x);
    if (currentFocus >= x.length) currentFocus = 0;
    if (currentFocus < 0) currentFocus = (x.length - 1);
    /*add class "autocomplete-active":*/
    x[currentFocus].classList.add("autocomplete-active");
  }
  function removeActive(x) {
    /*a function to remove the "active" class from all autocomplete items:*/
    for (var i = 0; i < x.length; i++) {
      x[i].classList.remove("autocomplete-active");
    }
  }
  function closeAllLists(elmnt) {
    /*close all autocomplete lists in the document,
    except the one passed as an argument:*/
    var x = document.getElementsByClassName("autocomplete-items");
    for (var i = 0; i < x.length; i++) {
      if (elmnt != x[i] && elmnt != inp) {
      x[i].parentNode.removeChild(x[i]);
    }
  }
}
/*execute a function when someone clicks in the document:*/
document.addEventListener("click", function (e) {
    closeAllLists(e.target);
});
}
</script>

<script>
var mykeywords = ["libvirt", "KubeVirt", "ClearContainers", "virtlet", "CRI", "OpenStack", "ovirt", "release notes", "changelog", "hilights", "network", "flannel", "kubevirt-ansible", "Skydive", "openshift", "glusterfs", "heketi", "virtual machine", "weavenet", "custom resources", "kubevirt objects", "objects", "VirtualMachine", "api", "rbac", "roles", "storage", "ovn", "kubetron", "neutron", "vscode", "development", "debug", "istio", "iptables", "tproxy", "service mesh", "ebtables", "docker", "container", "build", "multus", "roadmap", "kvm", "qemu", "device plugins", "unit testing", "review", "hugepages", "kubevirtci", "ci-cd", "cicd", "memory", "overcommitment", "networking", "CNI", "multiple networks", "ovs-cni", "import", "clone", "upload", "disk image", "cdi", "datavolumes", "volume types", "serviceaccount", "ignition", "coreos", "rhcos", "kubecon", "conference", "gcp", "autodeployer", "metrics", "prometheus", "grafana", "federation", "kubefed", "multicluster", "HCO", "hyperconverged operator", "ansible", "vagrant", "lifecycle", "virtual machines", "website", "community", "vm import", "node drain", "eviction", "nmo", "condition types", "Condition types", "CNCF", "sandbox", "lab", "cri-o", "quickstart", "homelab", "kubernetes", "kubevirt installation", "rook", "ceph", "ntp", "chronyd", "prow", "infrastructure", "kubevirt-tutorial", "CI-CD", "continuous integration", "jenkins", "noVNC", "console", "KubeCon", "cloudnativecon", "America", "talk", "gathering", "contra-lib", "admin", "operations", "create vm", "start vm", "connect to console", "connect to ssh", "stop vm", "remove vm", "operator manual", "basic operations", "laboratory", "installing kubevirt", "use kubevirt", "admin operations", "CDI", "containerized data importer", "octant", "okd", "openshift console", "cockpit", "user interface", "web interface", "virtVNC", "OKD console", "kubevirt upgrade", "upgrading", "OpenShift web console", "OKD", "video", "virtual machine management", "NUMA", "CPU pinning", "QEMU", "KVM", "GPU", "NVIDIA", "GPU workloads", "pass-through", "passthrough", "kubevirt", "Microsoft Windows kubernetes", "Microsoft Windows container", "Windows", "VM", "Advanced VM scheduling", "affinity", "scheduling", "topologyKeys", "Live Migration", "design", "architecture", "security", "operation", "images", "Kubernetes", "windows", "common-templates", "minikube", "addons", "oVirt", "kubevirt-hyperconverged", "cnao", "cluster-network-addons-operator", "kubernetes-nmstate", "nmstate", "bridge", "containerDisk", "registry", "composer-cli", "virt-customize", "builder tool", "prometheus-operator", "node-exporter", "monitoring", "event", "Tekton Pipelines", "KubeVirt Tekton Tasks", "vGPU", "Intel", "Fedora", "go", "authentication", "mesh", "AWS", "EC2", "AMI", "real-time", "CPUManager", "live migration", "dedicated network", "Kubevirt", "load-balancer", "MetalLB", "instancetypes", "preferences", "VirtualMachineInstancetype", "VirtualMachinePreference", ]
autocomplete(document.getElementById("search-input"), mykeywords);
</script>

<script src="/js/clipboard.min.js"></script>

    </nav>

    <main role="main" style="margin-top: 60px;">
      <div class="container">
  <div class="row">
    <div class="col">
      <div class="post">
        <header class="post-header">
          <h1></h1>
          <h1 class="post-title">Using Intel vGPUs with Kubevirt</h1>
          <div class="post-info">
            <span class="post-author">Author: Mark DeNeve</span>
            <div>
              <span class="post-category-name">
                Tags: <a href="/tag/kubevirt">kubevirt</a>&nbsp;|&nbsp;<a href="/tag/vgpu">vGPU</a>&nbsp;|&nbsp;<a href="/tag/windows">Windows</a>&nbsp;|&nbsp;<a href="/tag/gpu">GPU</a>&nbsp;|&nbsp;<a href="/tag/intel">Intel</a>&nbsp;|&nbsp;<a href="/tag/minikube">minikube</a>&nbsp;|&nbsp;<a href="/tag/fedora">Fedora</a>
              </span>
            </div>
            <div>
              <span class="post-meta">Publication Date: April 30, 2021  </span>
            </div>
            <div>
              <span class="post-category-name">
                Category: news
              </span>
            </div>

          </div>
        </header>
        <article class="post-content">
          <!-- TOC depthFrom:2 insertAnchor:false orderedList:false updateOnSave:true withLinks:true -->
<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li><a href="#prerequisites">Prerequisites</a>
    <ul>
      <li><a href="#fedora-workstation-prep">Fedora Workstation Prep</a></li>
      <li><a href="#preparing-the-intel-vgpu-driver">Preparing the Intel vGPU driver</a></li>
    </ul>
  </li>
  <li><a href="#install-kubernetes-with-minikube">Install Kubernetes with minikube</a></li>
  <li><a href="#install-kubevirt">Install kubevirt</a>
    <ul>
      <li><a href="#validate-vgpu-detection">Validate vGPU detection</a></li>
      <li><a href="#install-containerize-data-importer">Install Containerize Data Importer</a></li>
    </ul>
  </li>
  <li><a href="#install-windows">Install Windows</a></li>
  <li><a href="#accessing-the-windows-vm">Accessing the Windows VM</a></li>
  <li><a href="#using-the-gpu">Using the GPU</a>
<!-- /TOC --></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>Graphical User Interfaces (GUIs) have come along way over the past few years and most modern desktop environments expect some form of GPU acceleration in order to give you a seamless user experience. If you have tried running things like Windows 10 within Kubevirt you may have noticed that the desktop experience felt a little slow. This is due to Windows 10 reliance on GPU acceleration. In addition many applications are also now taking advantage of GPU acceleration and it can even be used in web based applications such as “FishGL”:
<br /></p>

<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-nogpu.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-nogpu.png" itemprop="thumbnail" width="100%" alt="FishGL" />
    </a>
    <figcaption itemprop="caption description"></figcaption>
  </figure>
</div>

<p>Without GPU hardware acceleration the user experience of a Virtual machine can be greatly impacted.</p>

<p>Starting with 5th generation Intel Core processors that have embedded Intel graphics processing units it is possible to share the graphics processor between multiple virtual machines. In Linux, this sharing of a GPU is typically enabled through the use of mediated GPU devices, also known as vGPUs. Kubevirt has supported the use of GPUs including GPU passthrough and vGPU since v0.22.0 back in 2019. This support was centered around one specific vendor, and only worked with expensive enterprise class cards and required additional licensing. Starting with <a href="https://github.com/kubevirt/kubevirt/releases/tag/v0.40.0">Kubevirt 0.40</a> support for detecting and allocating the Intel based vGPUs has been added to Kubevirt. Support for the creation of these virtualized Intel GPUs is available in the Linux Kernel since the 4.19 release. What does this meaning for you? You no longer need additional drivers or licenses to test out GPU accelerated virtual machines.</p>

<p>The total number of Intel vGPUs you can create is dependent on your specific hardware as well as support for changing the Graphics aperture size and shared graphics memory within your BIOS. For more details on this see <a href="https://github.com/intel/gvt-linux/wiki/GVTg_Setup_Guide#53-create-vgpu-kvmgt-only">Create vGPU (KVMGT only)</a> in the Intel GVTg wiki. Minimally configured devices can typically make at least two vGPU devices.</p>

<p>You can reproduce this work on any Kubernetes cluster running kubevirt v0.40.0 or later, but the steps you need to take to load the kernel modules and enable the virtual devices will vary based on the underlying OS your Kubernetes cluster is running on. In order to demonstrate how you can enable this feature, we will use an all-in-one Kubernetes cluster built using Fedora 32 and minikube.</p>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">Note</p><p>This blog post is a more advanced topic and assumes some Linux and Kubernetes understanding.</p>


</div></div>
<h2 id="prerequisites">Prerequisites</h2>

<p>Before we begin you will need a few things to make use of the Intel GPU:</p>

<ul>
  <li>A workstation or server with a 5th Generation or higher Intel Core Processor, or E3_v4 or higher Xeon Processor and enough memory to virtualize one or more VMs</li>
  <li>A preinstalled Fedora 32 Workstation with at least 50Gb of free space in the “/” filesystem</li>
  <li>The following software:
    <ul>
      <li>minikube - See <a href="https://minikube.sigs.k8s.io/docs/start/">minikube start</a></li>
      <li>virtctl - See <a href="https://github.com/kubevirt/kubevirt/releases">kubevirt releases</a></li>
      <li>kubectl - See <a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/">Install and Set Up kubectl on Linux</a></li>
    </ul>
  </li>
  <li>A Windows 10 Install ISO Image - See <a href="https://www.microsoft.com/en-us/software-download/windows10">Download Windows 10 Disk Image</a></li>
</ul>

<h3 id="fedora-workstation-prep">Fedora Workstation Prep</h3>

<p>In order to use minikube on Fedora 32 we will be installing multiple applications that will be used throughout this demo. In addition we will be configuring the workstation to use cgroups v1 and we will be updating the firewall to allow proper communication to our Kubernetes cluster as well as any hosted applications. Finally we will be disabling SELinux per the minikube bare-metal install instructions:</p>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">Note</p><p>This post assumes that we are starting with a fresh install of Fedora 32. If you are using an existing configured Fedora 32 Workstation, you may have some software conflicts.</p>


</div></div>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf update <span class="nt">-y</span>
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> pciutils podman podman-docker conntrack tigervnc rdesktop
<span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>ALL <span class="nt">--args</span><span class="o">=</span><span class="s2">"systemd.unified_cgroup_hierarchy=0"</span>
<span class="c"># Setup firewall rules to allow inbound and outbound connections from your minikube cluster</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>30000-65535/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>30000-65535/udp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>10250-10252/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>10248/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>2379-2380/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>6443/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>8443/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-port</span><span class="o">=</span>9153/tcp <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-service</span><span class="o">=</span>dns <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-interface</span><span class="o">=</span>cni-podman0 <span class="nt">--permanent</span>
<span class="nb">sudo </span>firewall-cmd <span class="nt">--add-masquerade</span> <span class="nt">--permanent</span>
<span class="nb">sudo </span>vi /etc/selinux/config
<span class="c"># change the "SELINUX=enforcing" to "SELINUX=permissive"</span>
<span class="nb">sudo </span>setenforce 0
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>sshd <span class="nt">--now</span>
</code></pre></div></div>

<p>We will now install the CRIO runtime:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf module <span class="nb">enable</span> <span class="nt">-y</span> cri-o:1.18
<span class="nb">sudo </span>dnf <span class="nb">install</span> <span class="nt">-y</span> cri-o cri-tools
<span class="nb">sudo </span>systemctl <span class="nb">enable</span> <span class="nt">--now</span> crio
</code></pre></div></div>

<h3 id="preparing-the-intel-vgpu-driver">Preparing the Intel vGPU driver</h3>

<p>In order to make use of the Intel vGPU driver, we need to make a few changes to our all-in-one host. The commands below assume you are using a Fedora based host. If you are using a different base OS, be sure to update your commands for that specific distribution.</p>

<p>The following commands will do the following:</p>

<ul>
  <li>load the kvmgt module to enable support within kvm</li>
  <li>enable gvt in the i915 module</li>
  <li>update the Linux kernel to enable Intel IOMMU</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>sh <span class="nt">-c</span> <span class="s2">"echo kvmgt &gt; /etc/modules-load.d/gpu-kvmgt.conf"</span>
<span class="nb">sudo </span>grubby <span class="nt">--update-kernel</span><span class="o">=</span>ALL <span class="nt">--args</span><span class="o">=</span><span class="s2">"intel_iommu=on i915.enable_gvt=1"</span>
<span class="nb">sudo </span>shutdown <span class="nt">-r</span> now
</code></pre></div></div>

<p>After the reboot check to ensure that the proper kernel modules have been loaded:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>lsmod | <span class="nb">grep </span>kvmgt
kvmgt                  32768  0
mdev                   20480  2 kvmgt,vfio_mdev
vfio                   32768  3 kvmgt,vfio_mdev,vfio_iommu_type1
kvm                   798720  2 kvmgt,kvm_intel
i915                 2494464  4 kvmgt
drm                   557056  4 drm_kms_helper,kvmgt,i915
</code></pre></div></div>

<p>We will now create our vGPU devices. These virtual devices are created by echoing a GUID into a sys device created by the Intel driver. This needs to be done every time the system boots. The easiest way to do this is using a systemd service that runs on every boot. Before we create this systemd service, we need to validate the PCI ID of your Intel Graphics card. To do this we will use the <code class="language-plaintext highlighter-rouge">lspci</code> command</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>lspci
00:00.0 Host bridge: Intel Corporation Device 9b53 <span class="o">(</span>rev 03<span class="o">)</span>
00:02.0 VGA compatible controller: Intel Corporation Device 9bc8 <span class="o">(</span>rev 03<span class="o">)</span>
00:08.0 System peripheral: Intel Corporation Xeon E3-1200 v5/v6 / E3-1500 v5 / 6th/7th/8th Gen Core Processor Gaussian Mixture Model
</code></pre></div></div>

<p>Take note that in the above output the Intel GPU is on “00:02.0”. Now create the <code class="language-plaintext highlighter-rouge">/etc/systemd/system/gvtg-enable.service</code> but be sure to update the PCI ID as appropriate for your machine:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> ~/gvtg-enable.service <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
[Unit]
Description=Create Intel GVT-g vGPU

[Service]
Type=oneshot
ExecStart=/bin/sh -c "echo '56a4c4e2-c81f-4cba-82bf-af46c30ea32d' &gt; /sys/devices/pci0000:00/0000:00:02.0/mdev_supported_types/i915-GVTg_V5_8/create"
ExecStart=/bin/sh -c "echo '973069b7-2025-406b-b3c9-301016af3150' &gt; /sys/devices/pci0000:00/0000:00:02.0/mdev_supported_types/i915-GVTg_V5_8/create"
ExecStop=/bin/sh -c "echo '1' &gt; /sys/devices/pci0000:00/0000:00:02.0/56a4c4e2-c81f-4cba-82bf-af46c30ea32d/remove"
ExecStop=/bin/sh -c "echo '1' &gt; /sys/devices/pci0000:00/0000:00:02.0/973069b7-2025-406b-b3c9-301016af3150/remove"
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
</span><span class="no">EOF
</span><span class="nb">sudo mv</span> ~/gvtg-enable.service /etc/systemd/system/gvtg-enable.service
<span class="nb">sudo </span>systemctl <span class="nb">enable </span>gvtg-enable <span class="nt">--now</span>
</code></pre></div></div>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">Note</p><p>The above systemd service will create two vGPU devices, you can repeat the commands with additional unique GUIDs up to a maximum of 8 vGPU if your particular hardware supports it.</p>


</div></div>
<p>We can validate that the vGPU devices were created by looking in the <code class="language-plaintext highlighter-rouge">/sys/devices/pci0000:00/0000:00:02.0/</code> directory.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lsa</span> /sys/devices/pci0000:00/0000:00:02.0/56a4c4e2-c81f-4cba-82bf-af46c30ea32d
total 0
lrwxrwxrwx. 1 root root    0 Apr 20 13:56 driver -&gt; ../../../../bus/mdev/drivers/vfio_mdev
drwxr-xr-x. 2 root root    0 Apr 20 14:41 intel_vgpu
lrwxrwxrwx. 1 root root    0 Apr 20 14:41 iommu_group -&gt; ../../../../kernel/iommu_groups/8
lrwxrwxrwx. 1 root root    0 Apr 20 14:41 mdev_type -&gt; ../mdev_supported_types/i915-GVTg_V5_8
drwxr-xr-x. 2 root root    0 Apr 20 14:41 power
<span class="nt">--w-------</span><span class="nb">.</span> 1 root root 4096 Apr 20 14:41 remove
lrwxrwxrwx. 1 root root    0 Apr 20 13:56 subsystem -&gt; ../../../../bus/mdev
<span class="nt">-rw-r--r--</span><span class="nb">.</span> 1 root root 4096 Apr 20 13:56 uevent
</code></pre></div></div>

<p>Note that “mdev_type” points to “i915-GVTg_V5_8”, this will come into play later when we configure kubevirt to detect the vGPU.</p>

<h2 id="install-kubernetes-with-minikube">Install Kubernetes with minikube</h2>

<p>We will now install Kubernetes onto our Fedora Workstation. <a href="https://minikube.sigs.k8s.io/docs/">Minikube</a> will help quickly set up our Kubernetes cluster environment. We will start by getting the latest release of minikube and kubectl.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-LO</span> https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
<span class="nb">sudo install </span>minikube-linux-amd64 /usr/local/bin/minikube
<span class="nv">VERSION</span><span class="o">=</span><span class="si">$(</span>minikube kubectl version | <span class="nb">head</span> <span class="nt">-1</span> | <span class="nb">awk</span> <span class="nt">-F</span><span class="s1">', '</span> <span class="o">{</span><span class="s1">'print $3'</span><span class="o">}</span> | <span class="nb">awk</span> <span class="nt">-F</span><span class="s1">':'</span> <span class="o">{</span><span class="s1">'print $2'</span><span class="o">}</span> | <span class="nb">sed </span>s/<span class="se">\"</span>//g<span class="si">)</span>
<span class="nb">sudo install</span> <span class="k">${</span><span class="nv">HOME</span><span class="k">}</span>/.minikube/cache/linux/<span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span>/kubectl /usr/local/bin
</code></pre></div></div>

<p>We will be using the minikube driver “none” which will install Kubernetes directly onto this machine. This will allow you to maintain a copy of the virtual machines that you build through a reboot. Later in this post we will create persistent volumes for virtual machine storage in “/data”. As previously noted, ensure that you have at least 50Gb of free space in “/data” to complete this setup. The minikube install will take a few minutes to complete.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo mkdir</span> <span class="nt">-p</span> /data/winhd1-pv
<span class="nv">$ </span><span class="nb">sudo </span>minikube start <span class="nt">--driver</span><span class="o">=</span>none <span class="nt">--container-runtime</span><span class="o">=</span>crio
😄  minikube v1.19.0 on Fedora 32
✨  Using the none driver based on user configuration
👍  Starting control plane node minikube <span class="k">in </span>cluster minikube
🤹  Running on localhost <span class="o">(</span><span class="nv">CPUs</span><span class="o">=</span>12, <span class="nv">Memory</span><span class="o">=</span>31703MB, <span class="nv">Disk</span><span class="o">=</span>71645MB<span class="o">)</span> ...
ℹ️  OS release is Fedora 32 <span class="o">(</span>Workstation Edition<span class="o">)</span>
🐳  Preparing Kubernetes v1.20.2 on Docker 20.10.6 ...
    ▪ Generating certificates and keys ...
    ▪ Booting up control plane ...
    ▪ Configuring RBAC rules ...
🤹  Configuring <span class="nb">local </span>host environment ...
🔎  Verifying Kubernetes components...
    ▪ Using image gcr.io/k8s-minikube/storage-provisioner:v5
🌟  Enabled addons: storage-provisioner, default-storageclass
🏄  Done! kubectl is now configured to use <span class="s2">"minikube"</span> cluster and <span class="s2">"default"</span> namespace by default
</code></pre></div></div>

<p>In order to make our interaction with Kubernetes a little easier, we will need to copy some files and update our <code class="language-plaintext highlighter-rouge">.kube/config</code></p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> ~/.minikube/profiles/minikube
<span class="nb">sudo cp</span> <span class="nt">-r</span> /root/.kube /home/<span class="nv">$USER</span>
<span class="nb">sudo cp</span> /root/.minikube/ca.crt /home/<span class="nv">$USER</span>/.minikube/ca.crt
<span class="nb">sudo cp</span> /root/.minikube/profiles/minikube/client.crt /home/<span class="nv">$USER</span>/.minikube/profiles/minikube
<span class="nb">sudo cp</span> /root/.minikube/profiles/minikube/client.key /home/<span class="nv">$USER</span>/.minikube/profiles/minikube
<span class="nb">sudo chown</span> <span class="nt">-R</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /home/<span class="nv">$USER</span>/.kube
<span class="nb">sudo chown</span> <span class="nt">-R</span> <span class="nv">$USER</span>:<span class="nv">$USER</span> /home/<span class="nv">$USER</span>/.minikube
<span class="nb">sed</span> <span class="nt">-i</span>  <span class="s2">"s/root/home</span><span class="se">\/</span><span class="nv">$USER</span><span class="s2">/"</span> ~/.kube/config
</code></pre></div></div>

<p>Once the minikube install is complete, validate that everything is working properly.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl get nodes
NAME       STATUS   ROLES                  AGE    VERSION
kubevirt   Ready    control-plane,master   4m5s   v1.20.2
</code></pre></div></div>

<p>As long as you don’t get any errors, your base Kubernetes cluster is ready to go.</p>

<h2 id="install-kubevirt">Install kubevirt</h2>

<p>Our all-in-one Kubernetes cluster is now ready for installing Installing Kubevirt. Using the minikube addons manager, we will install kubevirt into our cluster:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>minikube addons <span class="nb">enable </span>kubevirt
kubectl <span class="nt">-n</span> kubevirt <span class="nb">wait </span>kubevirt kubevirt <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available <span class="nt">--timeout</span><span class="o">=</span>300s
</code></pre></div></div>

<p>At this point, we need to update our instance of kubevirt in the cluster. We need to configure kubevirt to detect the Intel vGPU by giving it an <em>mdevNameSelector</em> to look for, and a <em>resourceName</em> to assign to it. The <em>mdevNameSelector</em> comes from the “mdev_type” that we identified earlier when we created the two virtual GPUs. When the kubevirt device manager finds instances of this mdev type, it will record this information and tag the node with the identified resourceName. We will use this resourceName later when we start up our virtual machine.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> kubevirt-patch.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
spec:
  configuration:
    developerConfiguration:
      featureGates:
      - GPU
    permittedHostDevices:
      mediatedDevices:
      - mdevNameSelector: "i915-GVTg_V5_8"
        resourceName: "intel.com/U630"
</span><span class="no">EOF
</span>kubectl patch kubevirt kubevirt <span class="nt">-n</span> kubevirt <span class="nt">--patch</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat </span>kubevirt-patch.yaml<span class="si">)</span><span class="s2">"</span> <span class="nt">--type</span><span class="o">=</span>merge
</code></pre></div></div>

<p>We now need to wait for kubevirt to reload its configuration.</p>

<h3 id="validate-vgpu-detection">Validate vGPU detection</h3>

<p>Now that kubevirt is installed and running, lets ensure that the vGPU was identified correctly. Describe the minikube node, using the command <code class="language-plaintext highlighter-rouge">kubectl describe node</code> and look for the “Capacity” section. If kubevirt properly detected the vGPU you will see an entry for “intel.com/U630” with a capacity value of greater than 0.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl describe node
Name:               kubevirt
Roles:              control-plane,master
Labels:             beta.kubernetes.io/arch<span class="o">=</span>amd64
                    beta.kubernetes.io/os<span class="o">=</span>linux
...
Capacity:
  cpu:                            12
  devices.kubevirt.io/kvm:        110
  devices.kubevirt.io/tun:        110
  devices.kubevirt.io/vhost-net:  110
  ephemeral-storage:              71645Mi
  hugepages-1Gi:                  0
  hugepages-2Mi:                  0
  intel.com/U630:                 2
  memory:                         11822640Ki
  pods:                           110
</code></pre></div></div>

<p>There it is, intel.com/U630 - two of them are available.  Now all we need is a virtual machine to consume them.</p>

<h3 id="install-containerize-data-importer">Install Containerize Data Importer</h3>

<p>In order to install Windows 10, we are going to need to upload a Windows 10 install ISO to the cluster. This can be facilitated through the use of the Containerized Data Importer. The following steps are taken from the <a href="https://kubevirt.io/labs/kubernetes/lab2.html">Experiment with the Containerized Data Importer (CDI)</a> web page:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">VERSION</span><span class="o">=</span><span class="si">$(</span>curl <span class="nt">-s</span> https://github.com/kubevirt/containerized-data-importer/releases/latest | <span class="nb">grep</span> <span class="nt">-o</span> <span class="s2">"v[0-9]</span><span class="se">\.</span><span class="s2">[0-9]*</span><span class="se">\.</span><span class="s2">[0-9]*"</span><span class="si">)</span>
kubectl create <span class="nt">-f</span> https://github.com/kubevirt/containerized-data-importer/releases/download/<span class="nv">$VERSION</span>/cdi-operator.yaml
kubectl create <span class="nt">-f</span> https://github.com/kubevirt/containerized-data-importer/releases/download/<span class="nv">$VERSION</span>/cdi-cr.yaml
kubectl <span class="nt">-n</span> cdi <span class="nb">wait </span>cdi cdi <span class="nt">--for</span> <span class="nv">condition</span><span class="o">=</span>Available <span class="nt">--timeout</span><span class="o">=</span>300s
</code></pre></div></div>

<p>Now that our CDI is available, we will expose it for consumption using a nodePort. This will allow us to connect to the cdi-proxy in the next steps.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> cdi-nodeport.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: v1
kind: Service
metadata:
  name: cdi-proxy-nodeport
  namespace: cdi
spec:
  type: NodePort
  selector:
    cdi.kubevirt.io: cdi-uploadproxy
  ports:
    - port: 8443
      nodePort: 30443
</span><span class="no">EOF
</span>kubectl create <span class="nt">-f</span> cdi-nodeport.yaml
</code></pre></div></div>

<p>One final step, lets get the latest release of virtctl which we will be using as we install Windows.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">VERSION</span><span class="o">=</span><span class="si">$(</span>kubectl get kubevirt.kubevirt.io/kubevirt <span class="nt">-n</span> kubevirt <span class="nt">-o</span><span class="o">=</span><span class="nv">jsonpath</span><span class="o">=</span><span class="s2">"{.status.observedKubeVirtVersion}"</span><span class="si">)</span>
curl <span class="nt">-L</span> <span class="nt">-o</span> virtctl https://github.com/kubevirt/kubevirt/releases/download/<span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span>/virtctl-<span class="k">${</span><span class="nv">VERSION</span><span class="k">}</span><span class="nt">-linux-amd64</span>
<span class="nb">sudo install </span>virtctl /usr/local/bin
</code></pre></div></div>

<h2 id="install-windows">Install Windows</h2>

<p>At this point we can now install a Windows VM in order to test this feature. The steps below are based on <a href="https://kubevirt.io/2020/KubeVirt-installing_Microsoft_Windows_from_an_iso.html">KubeVirt: installing Microsoft Windows from an ISO</a> however we will be using Windows 10 instead of Windows Server 2012. The commands below assume that you have a Windows 10 ISO file called <code class="language-plaintext highlighter-rouge">win10-virtio.iso</code>. If you need a Windows 10 CD, please see <a href="https://www.microsoft.com/en-us/software-download/windows10">Download Windows 10 Disk Image</a> and come back here after you have obtained your install CD.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>virtctl image-upload <span class="se">\</span>
   <span class="nt">--image-path</span><span class="o">=</span>win10-virtio.iso <span class="se">\</span>
   <span class="nt">--pvc-name</span><span class="o">=</span>iso-win10 <span class="se">\</span>
   <span class="nt">--access-mode</span><span class="o">=</span>ReadWriteOnce <span class="se">\</span>
   <span class="nt">--pvc-size</span><span class="o">=</span>6G <span class="se">\</span>
   <span class="nt">--uploadproxy-url</span><span class="o">=</span>https://127.0.0.1:30443 <span class="se">\</span>
   <span class="nt">--insecure</span> <span class="se">\</span>
   <span class="nt">--wait-secs</span><span class="o">=</span>240
</code></pre></div></div>

<p>We need a place to store our Windows 10 virtual disk, use the following to create a 40Gb space to store our file. In order to do this within minikube we will manually create a PersistentVolume (PV) as well as a PersistentVolumeClaim (PVC). These steps assume that you have 45+ GiB of free space in “/”.  We will create a “/data” directory as well as a subdirectory for storing our PV. If you do not have at least 45 GiB of free space in “/”, you will need to free up space, or mount storage on “/data” to continue.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> win10-pvc.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
---
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pvwinhd1
spec:
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 43Gi
  claimRef:
    namespace: default
    name: winhd1
  hostPath:
    path: /data/winhd1-pv
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: winhd1
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 40Gi
</span><span class="no">EOF
</span>kubectl create <span class="nt">-f</span> win10-pvc.yaml
</code></pre></div></div>

<p>We can now create our Windows 10 virtual machine. Use the following to create a virtual machine definition file that includes a vGPU:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cat</span> <span class="o">&gt;</span> win10vm1.yaml <span class="o">&lt;&lt;</span> <span class="no">EOF</span><span class="sh">
apiVersion: kubevirt.io/v1alpha3
kind: VirtualMachine
metadata:
  name: win10vm1
spec:
  running: false
  template:
    metadata:
      creationTimestamp: null
      labels:
        kubevirt.io/domain: win10vm1
    spec:
      domain:
        clock:
          timer:
            hpet:
              present: false
            hyperv: {}
            pit:
              tickPolicy: delay
            rtc:
              tickPolicy: catchup
          utc: {}
        cpu:
          cores: 1
          sockets: 2
          threads: 1
        devices:
          gpus:
          - deviceName: intel.com/U630
            name: gpu1
          disks:
          - cdrom:
              bus: sata
            name: windows-guest-tools
          - bootOrder: 1
            cdrom:
              bus: sata
            name: cdrom
          - bootOrder: 2
            disk:
              bus: sata
            name: disk-1
          inputs:
          - bus: usb
            name: tablet
            type: tablet
          interfaces:
          - masquerade: {}
            model: e1000e
            name: nic-0
        features:
          acpi: {}
          apic: {}
          hyperv:
            relaxed: {}
            spinlocks:
              spinlocks: 8191
            vapic: {}
        machine:
          type: pc-q35-rhel8.2.0
        resources:
          requests:
            memory: 8Gi
      hostname: win10vm1
      networks:
      - name: nic-0
        pod: {}
      terminationGracePeriodSeconds: 3600
      volumes:
        - name: cdrom
          persistentVolumeClaim:
            claimName: iso-win10
        - name: disk-1
          persistentVolumeClaim:
            claimName: winhd1
        - containerDisk:
            image: quay.io/kubevirt/virtio-container-disk
          name: windows-guest-tools
</span><span class="no">EOF
</span>kubectl create <span class="nt">-f</span> win10vm1.yaml
</code></pre></div></div>

<div class="premonition note"><div class="fa fa-check-square"></div><div class="content"><p class="header">NOTE</p><p>This VM is not optimized to use virtio devices to simplify the OS install. By using SATA devices as well as an emulated e1000 network card, we do not need to worry about loading additional drivers.</p>


</div></div>
<p>The key piece of information that we have added to this virtual machine definition is this snippet of yaml:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="na">devices</span><span class="pi">:</span>
          <span class="na">gpus</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">deviceName</span><span class="pi">:</span> <span class="s">intel.com/U630</span>
            <span class="na">name</span><span class="pi">:</span> <span class="s">gpu1</span>
</code></pre></div></div>

<p>Here we are identifying the gpu device that we want to attach to this VM. The deviceName relates back to the name that we gave to kubevirt to identify the Intel GPU resources. It also is the same identifier that shows up in the “Capacity” section of a node when you run <code class="language-plaintext highlighter-rouge">kubectl describe node</code>.</p>

<p>We can now start the virtual machine:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl start win10vm1
kubectl get vmi <span class="nt">--watch</span>
</code></pre></div></div>

<p>When the output of shows that the vm is in a “Running” phase you can “CTRL+C” to end the watch command.</p>

<h2 id="accessing-the-windows-vm">Accessing the Windows VM</h2>

<p>Since we are running this VM on this local machine, we can now take advantage of the virtctl command to connect to the VNC console of the virtual machine.</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>virtctl vnc win10vm1
</code></pre></div></div>

<p>A new VNC Viewer window will open and you should now see the Windows 10 install screen. Follow standard Windows 10 install steps at this point.</p>

<p>Once the install is complete you have a Windows 10 VM running with a GPU available. You can test that GPU acceleration is available by opening the Windows 10 task manager, selecting Advanced and then select the “Performance” tab. Note that the first time you start up, Windows is still detecting and installing the appropriate drivers. It may take a minute or two for the GPU information to show up in the Performance tab.</p>

<p>Try testing out the GPU acceleration. Open a web browser in your VM and navigate to “https://webglsamples.org/fishtank/fishtank.html” HOWEVER don’t be surprised by the poor performance. The default kubevirt console does not take advantage of the GPU. For that we need to take one final step to use the Windows Remote Desktop Protocol (RDP) which can use the GPU.</p>

<h2 id="using-the-gpu">Using the GPU</h2>

<p>In order to take advantage of the virtual GPU we have added, we will need to connect to the virtual machine over Remote Desktop Protocol (RDP). Follow these steps to enable RDP:</p>

<ol>
  <li>In the Windows 10 search bar, type “<strong>Remote Desktop Settings</strong>” and then open the result.</li>
  <li>Select “<strong>Enable Remote Desktop</strong>” and confirm the change.</li>
  <li>Select “<strong>Advanced settings</strong>” and un-check “<strong>Require computers to use Network level Authentication</strong>”, and confirm this change.</li>
  <li>Finally reboot the Windows 10 Virtual machine.</li>
</ol>

<p>Now, run the following commands in order to expose the RDP server to outside your Kubernetes cluster:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>virtctl expose vm win10vm1 <span class="nt">--port</span><span class="o">=</span>3389 <span class="nt">--type</span><span class="o">=</span>NodePort <span class="nt">--name</span><span class="o">=</span>win10vm1-rdp
<span class="nv">$ </span>kubectl get svc
NAME           TYPE        CLUSTER-IP       EXTERNAL-IP   PORT<span class="o">(</span>S<span class="o">)</span>          AGE
kubernetes     ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP          18h
win10vm1-rdp   NodePort    10.105.159.184   &lt;none&gt;        3389:30627/TCP   39s
</code></pre></div></div>

<p>Note the port that was assigned to this service we will use it in the next step. In the above output the port is 30627.</p>

<p>We can now use the rdesktop tool to connect to our VM and get the full advantages of the vGPU. From a command line run <code class="language-plaintext highlighter-rouge">rdesktop localhost:&lt;port&gt;</code> being sure to update the port based on the output from above. When prompted by rdesktop accept the certificate. Log into your Windows 10 client. You can now test out the vGPU.</p>

<p>Let’s try FishGL again. Open a browser and go to <a href="https://webglsamples.org/fishtank/fishtank.html">https://webglsamples.org/fishtank/fishtank.html</a>. You should notice a large improvement in the applications performance. You can also open the Task Manager and look at the performance tab to see the GPU under load.
<br /></p>

<div class="my-gallery" itemscope="" itemtype="http://schema.org/ImageGallery">
  <figure itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject">
    <a href="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-gpu.png" itemprop="contentUrl" data-size="800x530">
      <img src="/assets/2021-04-30-intel-vgpu-kubevirt/fishgl-gpu.png" itemprop="thumbnail" width="100%" alt="FishGL" />
    </a>
    <figcaption itemprop="caption description"></figcaption>
  </figure>
</div>

<p>Note that since you are running your Fedora 32 workstation on this same GPU you are already sharing the graphics workload between your primary desktop, and the virtualized Windows Desktop also running on this machine.</p>

<p>Congratulations! You now have a VM running in Kubernetes using an Intel vGPU. If your test machine has enough resources you can repeat the steps and create multiple virtual machines all sharing the one Intel GPU.</p>

        </article>
        
        

<a class="twitter-share-button" href="https://twitter.com/intent/tweet?text=Using Intel vGPUs with Kubevirt&url=https://www.kubevirt.io/2021/intel-vgpu-kubevirt.html&screen_name=kubevirt" aria-label="Share this on Twitter">
  <i class="fab fa-twitter mr-1"></i> Tweet
</a>
<hr/>


      </div>
    </div>
  </div>
</div>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
<script src="/js/photoswipe-page.js">
</script>

    </main>

    <footer class="footer" role="footer">
      <div class="container-fluid">
  <div class="row justify-content-between">
    <div class="col-sm-12 col-md-5">
      <p>We are a <a href="https://cncf.io/">Cloud Native Computing Foundation</a> sandbox project.</p>
      <p><a href="https://cncf.io/"><img src="/assets/images/cncf-color.png" alt="Cloud Native Computing Foundation"/></a></p>
    </div>
    <div class="col-sm-12 col-md-5" style="text-align: center;">
      <p class="text-md-right">

        <a href="https://twitter.com/kubevirt" data-toggle="tooltip" data-placement="top" title="Follow us on Twitter!" aria-label="Visit us on Twitter" class="link-social-twitter">
          <i class="fab fa-twitter fa-lg"></i>
        </a>

        <a href="https://kubernetes.slack.com/archives/C8ED7RKFE" data-toggle="tooltip" data-placement="top" title="Join our Slack channel!" class="link-social-slack">
          <i class="fab fa-slack fa-lg"></i>
        </a>

        <a href="https://github.com/kubevirt" data-toggle="tooltip" data-placement="top" title="Check our GitHub!" class="link-social-github">
          <i class="fab fa-github fa-lg"></i>
        </a>

        <a href="https://groups.google.com/forum/#!forum/kubevirt-dev" data-toggle="tooltip" data-placement="top" title="Join our mailing list!" class="link-social-mail">
          <i class="fas fa-envelope fa-lg"></i>
        </a>

        <a href="https://calendar.google.com/calendar/u/0/embed?src=kubevirt@cncf.io" data-toggle="tooltip" data-placement="top" title="See our events calendar!" class="link-social-calendar">
          <i class="fas fa-calendar fa-lg"></i>
        </a>

        <a href="https://www.youtube.com/channel/UC2FH36TbZizw25pVT1P3C3g/videos" data-toggle="tooltip" data-placement="top" title="Subscribe to our YouTube channel!" class="link-social-youtube">
          <i class="fab fa-youtube fa-lg"></i>
        </a>

      </p>
    </div>
  </div>
  <div class="row">
    <div class="col text-sm-left footer-licensing" style="text-align: center;">
      Copyright 2022 The KubeVirt Contributors<br>
      Copyright 2022 The Linux Foundation. All Rights Reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href="https://www.linuxfoundation.org/trademark-usage">Trademark Usage</a> page.<br>
      This site is powered by <a href="https://www.netlify.com/legal/open-source-policy/">Netlify</a>.
      <p class="privacy-statement text-sm-left" style="text-align: center;">
        <a href="/privacy" class="privacy-statement-link">Privacy Statement</a>
      </p>
  </div>
</div>
<script src="/js/copy.js"></script>

    </footer>

    <script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js" integrity="sha384-3LK/3kTpDE/Pkp8gTNp2gR/2gOiwQ6QaO7Td0zV76UFJVhqLl4Vl3KL1We6q6wR9" crossorigin="anonymous"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.0/umd/popper.min.js" integrity="sha384-cs/chFZiN24E4KMATLdqdvsezGxaGsi4hLGOzlXwp5UZB1LY//20VyM2taTB4QvJ" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/js/bootstrap.min.js" integrity="sha384-uefMccjFJAIv6A+rW+L4AHf99KvxDjWSu1z9VI8SKNVmz4sk7buKt/6v9KI65qnm" crossorigin="anonymous"></script>
    <script src="/js/kubevirt-io.js"></script>
    <!-- Photoswipe -->
    <!-- Core JS file -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe.min.js"></script>
    <!-- UI JS file -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

    <!-- This comes from DTM/DPAL and must be latest entry in body-->

    <script type="text/javascript">
        if (("undefined" !== typeof _satellite) && ("function" === typeof _satellite.pageBottom)) {
            _satellite.pageBottom();
        }
    </script>
  </body>
</html>
